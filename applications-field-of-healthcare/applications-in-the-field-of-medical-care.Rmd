---
title: "applications-in-the-field-of-medical-care"
author: "Della"
date: "2025-02-01"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Now, we will examine **time series** analysis in the context of healthcare, starting from two case studies: influenza prediction and nowcasting and blood glycemic index prediction. Both uses are important for detecting common health problems. Furthermore, in both cases, these are not solved problems, but rather topics of ongoing research in academia and healthcare.
    
## Predicting the Flu

Predicting the weekly flu rate in a given geographic area is a long-standing and ongoing problem. Infectious disease experts and global security professionals agree that infectious diseases pose a significant risk to human well-being. This is the case with influenza, which affects vulnerable people around the world, causing hundreds of deaths every year, especially among the very young and very old. It is crucial, from both a health care and national security perspective, to develop accurate models of how the flu will develop in a given season. Flu prediction models help predict the virus specifically and also help researchers explore general theories about how infectious diseases travel geographically.

### Case Study on Flu in a Metropolitan Area

We will look at a dataset of weekly flu reports from a variety of administrative regions in France, corresponding to the years 2004 to 2013. We will predict the flu rate in Île-de-France, the Paris metropolitan region. You can download the data from Kaggle (https://perma.cc/W9VQ-UUJC).

#### Data exploration and cleansing

We will start by familiarizing ourselves with the raw data by first analyzing it in its tabular format:

```{r, echo=FALSE}
library(knitr)
library(data.table)

# Sample dataset
flu <- data.table(
  Id = c(3235, 3236, 3237, 3238, 3239, 3240),
  week = rep(201352, 6),
  region_code = c(42, 72, 83, 25, 26, 53),
  region_name = c("ALSACE", "AQUITAINE", "AUVERGNE", "BASSE-NORMANDIE", "BOURGOGNE", "BRETAGNE"),
  TauxGrippe = c(7, 0, 88, 15, 0, 67),
  flu_rate = c(7, 0, 88, 15, 0, 67)
)

# Create a clean table
kable(flu, caption = "Flu Data Table")
```

We also did some basic quality checks, like looking for NA in our variables of interest. We may not know where these NA values come from, but we will need to consider them:

```R
> nrow(flu[is.na(flu.rate)]) / nrow(flu)
[1] 0
> unique(flu[is.na(flu.rate)]$region_name)
character(0)
```

The overall index of NA data points is 0. Furthermore, our region of interest, Île-de-France, is not included in the list of regions with NA values. We did some data cleaning, separating the week and year portion of the timestamp column (which is currently in character format, not numeric or timestamp format):

```R
flu[, year := as.numeric(substr(week, 1, 4))]
flu[, wk   := as.numeric(substr(week, 5, 6))]
```

We will add a *Date* class column so that we can have better plotting axes for time than if we treated the data without a timestamp:

```R
flu[, date := ISOweek2date(paste0(substr(as.character(week), 1, 4), "-W", substr(as.character(week), 5, 6), "-1"))]
```

This line of code is a little complicated. To convert month/week combinations into dates, we add a component that indicates the day. This is the purpose of *paste0()*, which marks each date as the first day of the week, placing a "1" in a string that already designates the year and week (out of the 52 weeks of the year). Note the %U and %u in the format string: they have to do with marking time according to the week of the year and the day of the week, a somewhat unusual timestamp format. We then split the data relating specifically to Paris and sorted it by date:

```{r, echo=FALSE}
library(knitr)
library(data.table)

# Sample dataset
flu <- data.table(
  week = c(200401, 200402, 200403, 200404, 200405, 201348, 201349, 201350, 201351, 201352),
  date = as.Date(c("2003-12-29", "2004-01-05", "2004-01-12", "2004-01-19", "2004-01-26",
                   "2013-11-25", "2013-12-02", "2013-12-09", "2013-12-16", "2013-12-23")),
  flu.rate = c(66, 74, 88, 26, 17, 12, 10, 13, 49, 24)
)

# Create a formatted table
kable(flu, caption = "Flu Data Table")
```

If you've been paying attention, you'll be surprised by the line count. If there are 52 weeks in a year and we have 10 years of data, why do we have 522 rows? We expected 52 weeks x 10 years = 520 lines. Likewise, why are there two NA dates? If we go back to the original data, we have an explanation. Apparently it has a 53˚ for both 2004 and 2009. From time to time there is a year with 53 weeks instead of 52.

Next, we'll check that the data covers a full, regularly sampled date range by first making sure that each year has the same number of data points:

```{r, echo=FALSE}
library(knitr)
library(data.table)

# Sample dataset
paris.flu <- data.table(
  year = c(2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013),
  N = c(53, 52, 52, 52, 52, 53, 52, 52, 52, 52)
)

# Create a formatted table
kable(paris.flu, caption = "Paris Flu Data - Weekly Observations per Year")
```

We can see that the data is as expected; that is, each year (except the two we just looked at) has 52 weeks, and each year-to-week label has 10 data points, one for each year (except week 53). Since we consider the timestamps of the data, we will inspect the actual values of the **time series** (so far we have only considered time indexing). Is there a trend? We will analyze:

![By plotting the flu rate time series, we can see the seasonality of the flu rate](https://github.com/DellaCortef/time-series-pocket-reference/blob/main/applications-field-of-healthcare/images/flu-paris-ts.R.png?raw=true)

A partir de um simples gráfico de linhas, fica claro que há uma sazonalidade considerável (algo que você provavelmente já viu em sua própria comunidade). Esse gráfico sugere um forte componente sazonal, porém não sugere um drift temporal além da sazonalidade.

Things get complicated in the seasonal behavior of the 53rd week. If we want to fit a seasonal model, we need to define seasonality in weeks of the year and we cannot have variable seasonal sizes. While we can imagine some creative solutions to the 53rd week problem, we will choose to exclude this data:

```R
paris.flu <- paris.flu[week != 53]  
```

Whether deleting a data point is a significant problem will depend on the dataset and the question we are asking. Consider this as an exercise: explore other possibilities to adjust the data, keeping data from the 53rd week. There are several options for doing this. One of them is to merge the data from the 53rd week with the data from the 52nd, calculating the average of the two weeks. Another is to use a model that can take cyclical behavior into account, without being stuck with exactly the same cycle length each year. A third option is to use a machine learning model capable of accommodating this with some creative labeling of the data and thus indicating seasonality to the model as an input characteristic.

#### Tuning a seasonal ARIMA model

First, we will consider fitting a seasonal ARIMA model to the data due to strong seasonality. In this case, the periodicity of the data is 52, since the data is sampled weekly. We want to choose a relatively parsimonious model - without too many parameters - because, with 520 data points, our **time series** is not very long.

This **time series** is a good example of how we can go wrong if we rely too much on autopilot. For example, we can think about whether or not we should differentiate the data. Thus, we can consider the autocorrelation graph of the flu index and the autocorrelation of the **time series** differentiated from the flu index. Each is shown in the following figure:

![](https://github.com/DellaCortef/time-series-pocket-reference/blob/main/applications-field-of-healthcare/images/acf-paris-flu-rate.png?raw=true)

![In the first graph, we plot the autocorrelation function for the Paris flu index, and in the second graph, we plot the differentiated Paris flu index. We only analyzed a limited range of lag values.](https://github.com/DellaCortef/time-series-pocket-reference/blob/main/applications-field-of-healthcare/images/acf-diff-paris-flu-rate.png?raw=true)

![](https://github.com/DellaCortef/time-series-pocket-reference/blob/main/applications-field-of-healthcare/images/acf-paris-flu-lag-max.png?raw=true)

![In the first graph, we plot the autocorrelation function for the Paris flu index and, in the second graph, we plot the differentiated Paris flu index. We now examine a wider range of lag values.](https://github.com/DellaCortef/time-series-pocket-reference/blob/main/applications-field-of-healthcare/images/acf-diff-paris-flu-lag-max.png?raw=true)

This gives us a more realistic picture of the autocorrelation of our **time series**. As we can see, there are substantial autocorrelations at various lags, and this makes sense (at least in my experience) in a four-season climate. Flu rates will have a strong correlation with neighboring weeks - that is, close to the time of measurement.

They will also have a strong correlation, given seasonality, with lag periods around 52 or around 104, as this indicates annual seasonality. However, flu rates also have a very strong relationship with lag time periods due to intermediate values, such as half a year (26 weeks), as these lags are also related to seasonal differences and predictable meteorological variations. For example, we know that in half a year the flu value will probably have changed a little. If it was high before, it must now be low and vice versa, again due to seasonality. All of this is represented in the upper graph of the last figures.

Next, we look at the differentiated series, as illustrated in the last graph. Now we see that a considerable part of the **time series** autocorrelation has decreased. However, there is some autocorrelation across a range of values, not only at 52 or 104 weeks (one or two years), but also at intermediate values.

While we may be tempted to continue differentiating, we need to remember that real-world data will never fit perfectly into a SARIMA model. Instead, we will look for a reasonable way to model the data. We can consider seasonal differentiation once again, or adopt a different tactic and differentiate in linear time. We will plot each of these possibilities:

![](https://github.com/DellaCortef/time-series-pocket-reference/blob/main/applications-field-of-healthcare/images/plot-diff-diff-paris-flu-rate-52.png?raw=true)

![Plot two differentiating versions of our series to get an idea of the seasonal behavior of the data](https://github.com/DellaCortef/time-series-pocket-reference/blob/main/applications-field-of-healthcare/images/plot-diff-diff-paris-flu-rate-1.png?raw=true)